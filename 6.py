# 操作系统

# 1 select,poll和epoll

# 其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.

# 这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.

# selec,poll和epoll区别总结

# 基本上select有3个缺点:

# 连接数受限
# 查找配对速度慢
# 数据由内核拷贝到用户态
# poll改善了第一个缺点

# epoll改了三个缺点.

# 关于epoll的: http://www.cnblogs.com/my_life/articles/3968782.html

# 2 调度算法

# 先来先服务(FCFS, First Come First Serve)
# 短作业优先(SJF, Shortest Job First)
# 最高优先权调度(Priority Scheduling)
# 时间片轮转(RR, Round Robin)
# 多级反馈队列调度(multilevel feedback queue scheduling)
# 常见的调度算法总结:http://www.jianshu.com/p/6edf8174c1eb

# 实时调度算法:

# 最早截至时间优先 EDF
# 最低松弛度优先 LLF
# 3 死锁

# 原因:

# 竞争资源
# 程序推进顺序不当
# 必要条件:

# 互斥条件
# 请求和保持条件
# 不剥夺条件
# 环路等待条件
# 处理死锁基本方法:

# 预防死锁(摒弃除1以外的条件)
# 避免死锁(银行家算法)
# 检测死锁(资源分配图)
# 解除死锁
# 剥夺资源
# 撤销进程
# 死锁概念处理策略详细介绍:https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html

# 4 程序编译与链接

# 推荐: http://www.ruanyifeng.com/blog/2014/11/compiler.html

# Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)

# 以c语言为例:

# 1 预处理

# 预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：

# 将所有的“#define”删除，并展开所用的宏定义
# 处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”
# 处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的
# 删除所有注释
# 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号
# 保留所有的#pragma编译器指令。
# 2 编译

# 编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。

# 3 汇编

# 汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)

# 4 链接

# 链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。
# 链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。

# 5 静态链接和动态链接

# 静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来
# 静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库

# 动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序

# 6 虚拟内存技术

# 虚拟存储器是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.

# 7 分页和分段

# 分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。

# 分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。

# 分页与分段的主要区别

# 页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.
# 页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.
# 分页的作业地址空间是一维的.分段的地址空间是二维的.
# 8 页面置换算法

# 最佳置换算法OPT:不可能实现
# 先进先出FIFO
# 最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.
# clock算法
# 9 边沿触发和水平触发

# 边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件

# 数据库

# 1 事务

# 数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。
# 彻底理解数据库事务: http://www.hollischuang.com/archives/898

# 2 数据库索引

# 推荐: http://tech.meituan.com/mysql-index.html

# MySQL索引背后的数据结构及算法原理

# 聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理

# 3 Redis原理

# Redis是什么？

# 是一个完全开源免费的key-value内存数据库
# 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets
# Redis数据库

# ​ 通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作

# 速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万
# 持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof)
# 自动操作：对不同数据类型的操作都是自动的，很安全
# 快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。
# Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。
# Redis缺点

# 是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
# Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。
# 4 乐观锁和悲观锁

# 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

# 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

# 乐观锁与悲观锁的具体区别: http://www.cnblogs.com/Bob-FD/p/3352216.html

# 5 MVCC

# ​ 全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。

# MySQL的innodb引擎是如何实现MVCC的

# innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（事务的隔离级别请看这篇文章）下，具体各种数据库操作的实现：

# select：满足以下两个条件innodb会返回该行数据：
# 该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
# 该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。
# insert：将新插入的行的创建版本号设置为当前系统的版本号。
# delete：将要删除的行的删除版本号设置为当前系统的版本号。
# update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。
# 其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。

# ​ 由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。

# 通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。

# 参考：MVCC浅析

# 6 MyISAM和InnoDB

# MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。

# InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。

# mysql 数据库引擎: http://www.cnblogs.com/0201zcr/p/5296843.html
# MySQL存储引擎－－MyISAM与InnoDB区别: https://segmentfault.com/a/1190000008227211

# 网络

# 1 三次握手

# 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。
# 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
# 最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。
# 2 四次挥手

# 注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.

# 客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.
# 服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.
# 服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.
# 客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.
# 图解: http://blog.csdn.net/whuslei/article/details/6667471

# 3 ARP协议

# 地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。

# 4 urllib和urllib2的区别

# 这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.

# urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。
# urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。
# 5 Post和Get

# GET和POST有什么区别？及为什么网上的多数答案都是错的
# 知乎回答

# get: RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1
# post: RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1

# 6 Cookie和Session

 	
# Cookie

# Session

# 储存位置

# 客户端

# 服务器端

# 目的

# 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等

# 跟踪会话

# 安全性

# 不安全

# 安全

# session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。

# 7 apache和nginx的区别

# nginx 相对 apache 的优点：

# 轻量级，同样起web 服务，比apache 占用更少的内存及资源
# 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能
# 配置简洁
# 高度模块化的设计，编写模块相对简单
# 社区活跃
# apache 相对nginx 的优点：

# rewrite ，比nginx 的rewrite 强大
# 模块超多，基本想到的都可以找到
# 少bug ，nginx 的bug 相对较多
# 超稳定
# 8 网站用户密码保存

# 明文保存
# 明文hash后保存,如md5
# MD5+Salt方式,这个salt可以随机
# 知乎使用了Bcrypy(好像)加密
# 9 HTTP和HTTPS

# 状态码

# 定义

# 1xx 报告

# 接收到请求，继续进程

# 2xx 成功

# 步骤成功接收，被理解，并被接受

# 3xx 重定向

# 为了完成请求,必须采取进一步措施

# 4xx 客户端出错

# 请求包括错的顺序或不能完成

# 5xx 服务器出错

# 服务器无法完成显然有效的请求

# 403: Forbidden
# 404: Not Found

# HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA

# 10 XSRF和XSS

# CSRF(Cross-site request forgery)跨站请求伪造
# XSS(Cross Site Scripting)跨站脚本攻击
# CSRF重点在请求,XSS重点在脚本

# 11 幂等 Idempotence

# HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用)

# GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

# DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。

# POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。

# PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。

# 12 RESTful架构(SOAP,RPC)

# 推荐: http://www.ruanyifeng.com/blog/2011/09/restful.html

# 13 SOAP

# SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。

# 14 RPC

# RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

# 总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.

# 进化的顺序: RPC -> SOAP -> RESTful

# 15 CGI和WSGI

# CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。
# CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。

# WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。

# 官方说明：PEP-3333

# 16 中间人攻击

# 在GFW里屡见不鲜的,呵呵.

# 中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

# 17 c10k问题

# 所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。
# 推荐: https://my.oschina.net/xianggao/blog/664275

# 18 socket

# 推荐: http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml

# Socket=Ip address+ TCP/UDP + port

# 19 浏览器缓存

# 推荐: http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html

# 304 Not Modified

# 20 HTTP1.0和HTTP1.1

# 推荐: http://blog.csdn.net/elifefly/article/details/3964766

# 请求头Host字段,一个服务器多个网站
# 长链接
# 文件断点续传
# 身份认证,状态管理,Cache缓存
# HTTP请求8种方法介绍
# HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。

# GET

# GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。

# GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

# HEAD

# HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。

# POST

# POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

# PUT

# PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

# DELETE

# DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

# CONNECT

# CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

# OPTIONS

# OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

# TRACE

# TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

# HTTP/1.1之后增加的方法

# 在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：

# PATCH

# PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：

# 但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。
# 当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。

# 21 Ajax

# AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。

# *NIX

# unix进程间通信方式(IPC)

# 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
# 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
# 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
# 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺
# 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
# 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
# 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
# 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
# 数据结构

# 1 红黑树

# 红黑树与AVL的比较：

# AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；

# 红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；

# 所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。

# 红黑树详解: https://xieguanglei.github.io/blog/post/red-black-tree.html

# 教你透彻了解红黑树: https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md

# 编程题

# 1 台阶问题/斐波那契

# 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

# fib = lambda n: n if n <= 2 else fib(n - 1) + fib(n - 2)

# 第二种记忆方法

# def memo(func):

#     cache = {}

#     def wrap(*args):

#         if args not in cache:

#             cache[args] = func(*args)

#         return cache[args]

#     return wrap

 

 

# @memo

# def fib(i):

#     if i < 2:

#         return 1

#     return fib(i-1) + fib(i-2)

# 第三种方法

# def fib(n):

#     a, b = 0, 1

#     for _ in xrange(n):

#         a, b = b, a + b

#     return b

# 2 变态台阶问题

# 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

# fib = lambda n: n if n < 2 else 2 * fib(n - 1)

# 3 矩形覆盖

# 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

# 第2*n个矩形的覆盖方法等于第2*(n-1)加上第2*(n-2)的方法。

# f = lambda n: 1 if n < 2 else f(n - 1) + f(n - 2)

# 4 杨氏矩阵查找

# 在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

# 使用Step-wise线性搜索。

# def get_value(l, r, c):

#     return l[r][c]

 

# def find(l, x):

#     m = len(l) - 1

#     n = len(l[0]) - 1

#     r = 0

#     c = n

#     while c >= 0 and r <= m:

#         value = get_value(l, r, c)

#         if value == x:

#             return True

#         elif value > x:

#             c = c - 1

#         elif value < x:

#             r = r + 1

#     return False


 
